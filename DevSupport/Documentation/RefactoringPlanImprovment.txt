New refactoring plan

1. Migrare CompletƒÉ MudBlazor ‚Üí Radzen ‚ö†Ô∏è
‚Ä¢	Status: Inconsistent - unele pagini folosesc Radzen, altele MudBlazor
‚Ä¢	Exemplu: GestionarePersoane.razor.cs folose»ôte Radzen, dar CSS-ul referƒÉ MudBlazor
‚Ä¢	Ac»õiune: Migrare completƒÉ »ôi eliminare dependen»õe MudBlazor
====================================================================================================================================
2. Eliminare Diacritice din UI ‚ö†Ô∏è
‚Ä¢	Status: Par»õial implementat
‚Ä¢	Probleme gƒÉsite:

// GRE»òIT - √Æn PersonalMedicalDetailDto
[Required(ErrorMessage = "NumƒÉrul de licen»õƒÉ este obligatoriu")]

// CORECT
[Required(ErrorMessage = "Numarul de licenta este obligatoriu")]
‚Ä¢	Ac»õiune: Audit complet »ôi √Ænlocuire toate diacriticele
====================================================================================================================================
3. Simplificare Design - Max 2 Culori ‚ö†Ô∏è
‚Ä¢	Status: CSS-ul actual folose»ôte prea multe culori
‚Ä¢	Probleme: patient-list.css define»ôte ~15 variabile de culoare
‚Ä¢	Ac»õiune: Reducere la schema de 2 culori (primary + accent)
====================================================================================================================================
4. Eliminare Magic Strings ‚úÖ
// IMPLEMENTARE ENUM-URI
public enum StatusOptions
{
    [Display(Name = "Activ")] Active = 1,
    [Display(Name = "Inactiv")] Inactive = 2
}

public enum TipPersonalMedical
{
    [Display(Name = "Medic")] Medic = 1,
    [Display(Name = "Asistent")] Asistent = 2,
    [Display(Name = "Receptioner")] Receptioner = 3
}
====================================================================================================================================
5. Rich Services Implementation üîß
// √éNAINTE - GestionarePersoane doar forward data
public async Task LoadDataAsync(LoadDataArgs args)
{
    var response = await Http.GetAsync($"api/Persoane{queryString}");
}

// DUPƒÇ - Service cu business logic
public class PersonaManagementService
{
    public async Task<Result<PersonaWithValidation>> ValidateAndLoadPersona(int id)
    {
        var persona = await _repository.GetByIdAsync(id);
        
        // Validare CNP
        if (!CNPValidator.IsValid(persona.CNP))
            return Result.Failure<PersonaWithValidation>("CNP invalid");
            
        // Verificare duplicate
        var duplicates = await CheckDuplicates(persona);
        if (duplicates.Any())
            return Result.Failure<PersonaWithValidation>("Persoana duplicata");
            
        // Calcul varsta si validari medicale
        var medicalValidation = await ValidateMedicalHistory(persona);
        
        return Result.Success(new PersonaWithValidation(persona, medicalValidation));
    }
}
====================================================================================================================================
6. Result Pattern Everywhere ‚úÖ
public class Result<T>
{
    public bool IsSuccess { get; }
    public T? Value { get; }
    public List<string> Errors { get; }
    public string? SuccessMessage { get; }
    
    // Metode helper pentru Blazor
    public void ShowNotification(NotificationService service)
    {
        if (IsSuccess && !string.IsNullOrEmpty(SuccessMessage))
            service.Success(SuccessMessage);
        else if (!IsSuccess)
            service.Error(string.Join(", ", Errors));
    }
}
====================================================================================================================================
7. Component Code-Behind Separation üîß
// PersonalMedicalView.razor - DOAR MARKUP
@page "/medical/personal-view/{PersonalId:guid}"
@inherits PersonalMedicalViewBase

<RadzenCard Class="page-header-card view-mode">
    <!-- Doar UI, fƒÉrƒÉ @code block -->
</RadzenCard>

// PersonalMedicalView.razor.cs - TOATƒÇ LOGICA
public abstract class PersonalMedicalViewBase : ComponentBase
{
    // ToatƒÉ logica business aici
}
====================================================================================================================================
8. FluentValidation Integration ‚úÖ
public class CreatePersonaValidator : AbstractValidator<CreatePersonaRequest>
{
    public CreatePersonaValidator()
    {
        RuleFor(x => x.CNP)
            .NotEmpty().WithMessage("CNP este obligatoriu")
            .Length(13).WithMessage("CNP trebuie sa aiba 13 caractere")
            .Must(BeValidCNP).WithMessage("CNP invalid")
            .MustAsync(BeUniqueCNP).WithMessage("CNP deja existent");
            
        RuleFor(x => x.Varsta)
            .InclusiveBetween(0, 150).WithMessage("Varsta invalida");
    }
}
====================================================================================================================================
9. CSS Reorganizare CompletƒÉ üîß
wwwroot/css/
‚îú‚îÄ‚îÄ radzen-theme.css          # Doar customizƒÉri Radzen
‚îú‚îÄ‚îÄ app.css                    # Import principal
‚îî‚îÄ‚îÄ print.css                  # Stiluri print

// ELIMINƒÇM:
- patient-list.css (500+ linii)
- Toate override-urile MudBlazor
- CSS-uri complexe custom
====================================================================================================================================
10. Radzen Theme Simplificat ‚úÖ
/* radzen-theme.css - MINIMAL */
:root {
    --primary: #2563eb;      /* Albastru medical */
    --accent: #10b981;       /* Verde succes */
    --text: #1f2937;
    --background: #ffffff;
    --surface: #f9fafb;
    --border: #e5e7eb;
}

/* Doar override-uri esen»õiale */
.rz-button-primary { background: var(--primary); }
.rz-badge-success { background: var(--accent); }
====================================================================================================================================
11. Header Global Pattern ‚úÖ
<!-- Component reutilizabil -->
<PageHeader Mode="@HeaderMode.View" 
            Title="@($"Vizualizare {EntityName}")"
            Icon="visibility">
    <Actions>
        <RadzenButton Text="Editeaza" Icon="edit" Click="@Edit" />
    </Actions>
</PageHeader>
====================================================================================================================================
12. CQRS Implementation ‚úÖ
// Commands
public record CreatePersonaCommand(string Nume, string Prenume, string CNP) : ICommand<Result<int>>;

// Handlers
public class CreatePersonaCommandHandler : ICommandHandler<CreatePersonaCommand, Result<int>>
{
    public async Task<Result<int>> Handle(CreatePersonaCommand command, CancellationToken ct)
    {
        // Validare
        var validator = new CreatePersonaValidator();
        var validation = await validator.ValidateAsync(command);
        if (!validation.IsValid)
            return Result<int>.Failure(validation.Errors.Select(e => e.ErrorMessage).ToArray());
            
        // Business logic
        var persona = Persona.Create(command.Nume, command.Prenume, command.CNP);
        
        // Persistare
        await _repository.AddAsync(persona);
        
        // Event
        await _eventBus.PublishAsync(new PersonaCreatedEvent(persona.Id));
        
        return Result<int>.Success(persona.Id, "Persoana creata cu succes");
    }
}
====================================================================================================================================
13. SignalR Real-Time Updates ‚úÖ
public class MedicalNotificationHub : Hub
{
    public async Task NotifyAppointmentUpdate(AppointmentUpdateDto update)
    {
        await Clients.Group($"medical-{update.DoctorId}")
            .SendAsync("AppointmentUpdated", update);
    }
    
    public async Task JoinDoctorGroup(Guid doctorId)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, $"medical-{doctorId}");
    }
}
====================================================================================================================================
14. Caching Strategy ‚úÖ
public class CachedPersonalMedicalService : IPersonalMedicalService
{
    private readonly ICacheService _cache;
    private readonly IPersonalMedicalService _innerService;
    
    public async Task<Result<PersonalMedicalDetailDto>> GetByIdAsync(Guid id)
    {
        var cacheKey = $"personal-medical-{id}";
        
        var cached = await _cache.GetAsync<PersonalMedicalDetailDto>(cacheKey);
        if (cached != null)
            return Result<PersonalMedicalDetailDto>.Success(cached);
            
        var result = await _innerService.GetByIdAsync(id);
        
        if (result.IsSuccess)
            await _cache.SetAsync(cacheKey, result.Value, TimeSpan.FromMinutes(5));
            
        return result;
    }
}
====================================================================================================================================
15. Exception Handling Middleware ‚úÖ
public class GlobalExceptionMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        try
        {
            await next(context);
        }
        catch (ValidationException ex)
        {
            await HandleValidationException(context, ex);
        }
        catch (NotFoundException ex)
        {
            await HandleNotFoundException(context, ex);
        }
        catch (BusinessRuleException ex)
        {
            await HandleBusinessException(context, ex);
        }
    }
}
====================================================================================================================================

====================================================================================================================================
VERY IMPORTANT --> üìä PROBLEME SPECIFICE GƒÇSITE - DE REZOLVAT ACTIUNE IMEDIATA
====================================================================================================================================
16. DataGrid Settings Persistence ‚ö†Ô∏è
// PROBLEMƒÇ: Salvare √Æn localStorage poate e»ôua
await JSRuntime.InvokeVoidAsync("localStorage.setItem", GRID_SETTINGS_KEY, json);

// SOLU»öIE: Error handling »ôi fallback
try 
{
    await JSRuntime.InvokeVoidAsync("localStorage.setItem", GRID_SETTINGS_KEY, json);
}
catch
{
    // Salvare √Æn memory cache ca fallback
    _memoryCache.Set(GRID_SETTINGS_KEY, settings);
}
====================================================================================================================================
17. Memory Leaks √Æn Components ‚ö†Ô∏è
// PROBLEMƒÇ: Timer ne-disposed corect
private Timer? _searchTimer;

// SOLU»öIE: Dispose pattern complet
public void Dispose()
{
    _searchTimer?.Dispose();
    _cancellationTokenSource?.Cancel();
    _cancellationTokenSource?.Dispose();
    GC.SuppressFinalize(this);
}
====================================================================================================================================
18. Group State Management ‚ö†Ô∏è
// PROBLEMƒÇ: State complex pentru grupƒÉri
private Dictionary<string, bool> _groupStates = new();

// SOLU»öIE: State management service
public class DataGridStateService
{
    private readonly Dictionary<string, GridState> _states = new();
    
    public async Task SaveStateAsync(string gridId, GridState state)
    {
        _states[gridId] = state;
        await PersistToStorageAsync(gridId, state);
    }
}

